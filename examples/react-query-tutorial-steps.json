[
  {
    "title": "1. Setup and Installation",
    "notes": "First, install TanStack Query and set up the QueryClient provider in your app.",
    "language": "typescript",
    "code": "// Install dependencies\n// npm install @tanstack/react-query\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 1000 * 60 * 5, // 5 minutes\n      refetchOnWindowFocus: false,\n    },\n  },\n});\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <YourApp />\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  );\n}"
  },
  {
    "title": "2. Basic Query Hook",
    "notes": "Create a simple query to fetch data. This example fetches a list of todos.",
    "language": "typescript",
    "code": "import { useQuery } from '@tanstack/react-query';\n\ninterface Todo {\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\nasync function fetchTodos(): Promise<Todo[]> {\n  const response = await fetch('/api/todos');\n  if (!response.ok) {\n    throw new Error('Failed to fetch todos');\n  }\n  return response.json();\n}\n\nfunction TodoList() {\n  const { data, isLoading, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  });\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <ul>\n      {data?.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}"
  },
  {
    "title": "3. Query with Variables",
    "notes": "Use query variables to fetch specific data. This example fetches a single todo by ID.",
    "language": "typescript",
    "code": "import { useQuery } from '@tanstack/react-query';\n\ninterface Todo {\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\nasync function fetchTodo(id: number): Promise<Todo> {\n  const response = await fetch(`/api/todos/${id}`);\n  if (!response.ok) {\n    throw new Error('Failed to fetch todo');\n  }\n  return response.json();\n}\n\nfunction TodoDetail({ todoId }: { todoId: number }) {\n  const { data, isLoading, error } = useQuery({\n    queryKey: ['todos', todoId],\n    queryFn: () => fetchTodo(todoId),\n    enabled: !!todoId, // Only run query if todoId exists\n  });\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      <h2>{data?.title}</h2>\n      <p>Completed: {data?.completed ? 'Yes' : 'No'}</p>\n    </div>\n  );\n}"
  },
  {
    "title": "4. Creating Mutations",
    "notes": "Use mutations to create, update, or delete data. This example creates a new todo.",
    "language": "typescript",
    "code": "import { useMutation, useQueryClient } from '@tanstack/react-query';\n\ninterface Todo {\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\ninterface CreateTodoInput {\n  title: string;\n  completed?: boolean;\n}\n\nasync function createTodo(input: CreateTodoInput): Promise<Todo> {\n  const response = await fetch('/api/todos', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(input),\n  });\n  if (!response.ok) {\n    throw new Error('Failed to create todo');\n  }\n  return response.json();\n}\n\nfunction CreateTodoForm() {\n  const queryClient = useQueryClient();\n  \n  const mutation = useMutation({\n    mutationFn: createTodo,\n    onSuccess: () => {\n      // Invalidate and refetch todos list\n      queryClient.invalidateQueries({ queryKey: ['todos'] });\n    },\n  });\n\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    const formData = new FormData(e.currentTarget);\n    mutation.mutate({\n      title: formData.get('title') as string,\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"title\" placeholder=\"Todo title\" required />\n      <button type=\"submit\" disabled={mutation.isPending}>\n        {mutation.isPending ? 'Creating...' : 'Create Todo'}\n      </button>\n      {mutation.isError && (\n        <div>Error: {mutation.error.message}</div>\n      )}\n    </form>\n  );\n}"
  },
  {
    "title": "5. Updating with Mutations",
    "notes": "Update existing data using mutations. This example toggles a todo's completed status.",
    "language": "typescript",
    "code": "import { useMutation, useQueryClient } from '@tanstack/react-query';\n\ninterface Todo {\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\nasync function updateTodo(id: number, updates: Partial<Todo>): Promise<Todo> {\n  const response = await fetch(`/api/todos/${id}`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates),\n  });\n  if (!response.ok) {\n    throw new Error('Failed to update todo');\n  }\n  return response.json();\n}\n\nfunction TodoItem({ todo }: { todo: Todo }) {\n  const queryClient = useQueryClient();\n  \n  const toggleMutation = useMutation({\n    mutationFn: (completed: boolean) => \n      updateTodo(todo.id, { completed }),\n    onSuccess: () => {\n      // Invalidate both the list and this specific todo\n      queryClient.invalidateQueries({ queryKey: ['todos'] });\n      queryClient.invalidateQueries({ queryKey: ['todos', todo.id] });\n    },\n  });\n\n  return (\n    <div>\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={(e) => toggleMutation.mutate(e.target.checked)}\n        disabled={toggleMutation.isPending}\n      />\n      <span>{todo.title}</span>\n    </div>\n  );\n}"
  },
  {
    "title": "6. Optimistic Updates",
    "notes": "Update the UI immediately before the server responds, then rollback on error. This provides instant feedback.",
    "language": "typescript",
    "code": "import { useMutation, useQueryClient } from '@tanstack/react-query';\n\ninterface Todo {\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\nasync function updateTodo(id: number, updates: Partial<Todo>): Promise<Todo> {\n  const response = await fetch(`/api/todos/${id}`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates),\n  });\n  if (!response.ok) {\n    throw new Error('Failed to update todo');\n  }\n  return response.json();\n}\n\nfunction TodoItem({ todo }: { todo: Todo }) {\n  const queryClient = useQueryClient();\n  \n  const toggleMutation = useMutation({\n    mutationFn: (completed: boolean) => \n      updateTodo(todo.id, { completed }),\n    \n    // Optimistically update the cache\n    onMutate: async (newCompleted) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['todos', todo.id] });\n      \n      // Snapshot previous value\n      const previousTodo = queryClient.getQueryData<Todo>(['todos', todo.id]);\n      \n      // Optimistically update\n      queryClient.setQueryData<Todo>(['todos', todo.id], (old) => ({\n        ...old!,\n        completed: newCompleted,\n      }));\n      \n      return { previousTodo };\n    },\n    \n    // Rollback on error\n    onError: (err, newCompleted, context) => {\n      if (context?.previousTodo) {\n        queryClient.setQueryData(['todos', todo.id], context.previousTodo);\n      }\n    },\n    \n    // Refetch on success\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ['todos', todo.id] });\n    },\n  });\n\n  return (\n    <div>\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={(e) => toggleMutation.mutate(e.target.checked)}\n        disabled={toggleMutation.isPending}\n      />\n      <span>{todo.title}</span>\n    </div>\n  );\n}"
  },
  {
    "title": "7. Error Handling and Retry Logic",
    "notes": "Configure error handling and retry behavior for better user experience.",
    "language": "typescript",
    "code": "import { useQuery } from '@tanstack/react-query';\n\ninterface Todo {\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\nasync function fetchTodos(): Promise<Todo[]> {\n  const response = await fetch('/api/todos');\n  if (!response.ok) {\n    throw new Error('Failed to fetch todos');\n  }\n  return response.json();\n}\n\nfunction TodoList() {\n  const { data, isLoading, error, isError } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n    retry: 3, // Retry 3 times on failure\n    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    // Exponential backoff: 1s, 2s, 4s, max 30s\n  });\n\n  if (isLoading) return <div>Loading...</div>;\n  \n  if (isError) {\n    return (\n      <div>\n        <p>Error: {error.message}</p>\n        <button onClick={() => queryClient.invalidateQueries({ queryKey: ['todos'] })}>\n          Retry\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <ul>\n      {data?.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}"
  },
  {
    "title": "8. Dependent Queries",
    "notes": "Chain queries where one depends on the result of another. This example fetches user details, then their todos.",
    "language": "typescript",
    "code": "import { useQuery } from '@tanstack/react-query';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface Todo {\n  id: number;\n  userId: number;\n  title: string;\n  completed: boolean;\n}\n\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  if (!response.ok) throw new Error('Failed to fetch user');\n  return response.json();\n}\n\nasync function fetchUserTodos(userId: number): Promise<Todo[]> {\n  const response = await fetch(`/api/users/${userId}/todos`);\n  if (!response.ok) throw new Error('Failed to fetch todos');\n  return response.json();\n}\n\nfunction UserTodos({ userId }: { userId: number }) {\n  // First, fetch the user\n  const { data: user } = useQuery({\n    queryKey: ['users', userId],\n    queryFn: () => fetchUser(userId),\n  });\n\n  // Then, fetch todos for that user (only runs after user is loaded)\n  const { data: todos, isLoading } = useQuery({\n    queryKey: ['users', userId, 'todos'],\n    queryFn: () => fetchUserTodos(userId),\n    enabled: !!user, // Only run when user data is available\n  });\n\n  if (isLoading) return <div>Loading todos...</div>;\n\n  return (\n    <div>\n      <h2>{user?.name}'s Todos</h2>\n      <ul>\n        {todos?.map((todo) => (\n          <li key={todo.id}>{todo.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
  }
]

